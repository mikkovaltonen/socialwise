/**
 * Markdown Document Editor Component
 *
 * Allows users to create and edit client documents:
 * - LS-ilmoitukset (Child Protection Notifications)
 * - P√§√§t√∂kset (Decisions)
 * - PTA (Service Need Assessments)
 * - Asiakassuunnitelmat (Service Plans)
 * - Asiakaskirjaukset (Case Notes)
 * - Yhteystiedot (Contact Information)
 */

import React, { useState, useEffect } from 'react';
import * as FirestoreService from '@/lib/firestoreDocumentService';
import { extractDateFromMarkdown } from '@/lib/aineistoParser';
import type { DocumentCategory } from '@/lib/firestoreDocumentService';
import { getClientBasicInfo } from '@/lib/clientService';
import { auth } from '@/lib/firebase';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Button } from '@/components/ui/button';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Save, X, Edit3, AlertCircle, Check, Loader2, Maximize2, Minimize2, Trash2, Lock } from 'lucide-react';

// Document type definitions
export type DocumentType =
  | 'ls-ilmoitus'
  | 'p√§√§t√∂s'
  | 'pta'
  | 'asiakassuunnitelma'
  | 'asiakaskirjaus'
  | 'yhteystiedot';

interface DocumentSection {
  heading: string;
  content: string;
  locked: boolean;
  isMetadata?: boolean;
  readOnly?: boolean;        // Prevents user from editing content
  autoGenerated?: boolean;   // Indicates field is system-generated
  placeholder?: string;      // Placeholder text for textarea
}

interface MarkdownDocumentEditorProps {
  open: boolean;
  onClose: () => void;
  documentType: DocumentType;
  clientId: string;
  existingContent?: string;
  existingFilename?: string;
  onSaved?: () => void;
}

// Structured document templates with locked headings
const DOCUMENT_STRUCTURES: Record<DocumentType, DocumentSection[]> = {
  'ls-ilmoitus': [
    { heading: '# Lastensuojeluhakemus', content: '', locked: true, isMetadata: true },
    {
      heading: '## P√ÑIV√ÑYS',
      content: '',
      locked: true,
      readOnly: true,
      autoGenerated: true
    },
    {
      heading: '## ILMOITTAJAN TIEDOT',
      content: '',
      locked: true
    },
    {
      heading: '## LAPSEN TIEDOT',
      content: '',
      locked: true,
      readOnly: true,
      autoGenerated: true
    },
    {
      heading: '## HUOLTAJIEN TIEDOT',
      content: '',
      locked: true,
      readOnly: true,
      autoGenerated: true
    },
    { heading: '## HUOLEN AIHEET', content: '', locked: true },
    { heading: '## ILMOITUKSEN PERUSTE', content: '', locked: true },
    { heading: '## TOIMENPITEET', content: '', locked: true },
    { heading: '## ALLEKIRJOITUS JA K√ÑSITTELYN P√Ñ√ÑTTYMISP√ÑIV√ÑM√Ñ√ÑR√Ñ', content: '', locked: true },
  ],

  'p√§√§t√∂s': [
    { heading: '## RATKAISU TAI P√Ñ√ÑT√ñS', content: '', locked: true },
    { heading: '## ASIAN VIREILLETULOP√ÑIV√Ñ', content: new Date().toLocaleDateString('fi-FI'), locked: true, isMetadata: true },
    { heading: '## ASIAN KESKEINEN SIS√ÑLT√ñ', content: '', locked: true },
    { heading: '## P√Ñ√ÑT√ñKSEN PERUSTELUT JA TOIMEENPANO', content: '', locked: true },
    { heading: '## RATKAISU VOIMASSA', content: '', locked: true },
    { heading: '## VALMISTELIJA / LAPSEN ASIOISTA VASTAAVA SOSIAALITY√ñNTEKIJ√Ñ', content: '', locked: true },
    { heading: '## RATKAISIJA / VASTUUSOSIAALITY√ñNTEKIJ√Ñ / JOHTAVA SOSIAALITY√ñNTEKIJ√Ñ', content: '', locked: true },
    { heading: '## TIEDOKSIANTO PMV', content: '', locked: true },
  ],

  'pta': [
    { heading: '## P√§iv√§ys', content: '', locked: true },
    { heading: '## PERHE', content: '', locked: true },
    { heading: '## TAUSTA', content: '', locked: true },
    { heading: '## PALVELUT', content: '', locked: true },
    { heading: '## YHTEISTY√ñTAHOT ja VERKOSTO', content: '', locked: true },
    { heading: '## LAPSEN JA PERHEEN TAPAAMINEN', content: '', locked: true },
    { heading: '## ASIAKKAAN MIELIPIDE JA N√ÑKEMYS PALVELUTARPEESEEN', content: '', locked: true },
    { heading: '## SOSIAALIHUOLLON AMMATTIHENKIL√ñN JOHTOP√Ñ√ÑT√ñKSET', content: '', locked: true },
    { heading: '## ARVIO OMATY√ñNTEKIJ√ÑN TARPEESTA', content: '', locked: true },
    { heading: '## JAKELU JA ALLEKIRJOITUS', content: '', locked: true },
  ],

  'asiakassuunnitelma': [
    { heading: '# Asiakassuunnitelma', content: '', locked: true },
    { heading: `**P√§iv√§ys:** ${new Date().toLocaleDateString('fi-FI')}`, content: '', locked: true, isMetadata: true },
    { heading: '## L√§ht√∂tilanne', content: '', locked: true },
    { heading: '## Tavoitteet', content: '', locked: true },
    { heading: '## Toimenpiteet', content: '', locked: true },
    { heading: '## Seuranta ja arviointi', content: '', locked: true },
  ],

  'asiakaskirjaus': [
    { heading: '# Asiakaskirjaus', content: '', locked: true },
    { heading: `**P√§iv√§ys:** ${new Date().toLocaleDateString('fi-FI')}`, content: '', locked: true, isMetadata: true },
  ],

  'yhteystiedot': [
    { heading: '# Yhteystiedot', content: '', locked: true },
    { heading: '## Asiakas', content: '', locked: true },
    { heading: '## Yhteyshenkil√∂t', content: '', locked: true },
    { heading: '## Verkosto', content: '', locked: true },
    { heading: '## Huomioitavaa', content: '', locked: true },
  ],
};

// Helper function to parse existing content into sections
function parseContentIntoSections(content: string, structure: DocumentSection[]): DocumentSection[] {
  if (!content) return structure;

  const lines = content.split('\n');
  const sections = [...structure];
  let currentSectionIndex = -1;
  let currentContent: string[] = [];

  for (const line of lines) {
    // Check if this line is a heading from our structure
    // For flexible matching, try exact match first, then partial match for non-metadata sections
    let headingMatch = sections.findIndex((s, idx) =>
      line.trim() === s.heading.trim() && idx > currentSectionIndex
    );

    // If no exact match and line is a heading, try to find by heading text (ignoring # symbols)
    if (headingMatch === -1 && line.trim().startsWith('#')) {
      const lineHeadingText = line.trim().replace(/^#+\s*/, '').toLowerCase();
      headingMatch = sections.findIndex((s, idx) => {
        const sectionHeadingText = s.heading.replace(/^#+\s*/, '').toLowerCase();
        return lineHeadingText === sectionHeadingText && idx > currentSectionIndex && !s.isMetadata;
      });
    }

    if (headingMatch !== -1) {
      // Save previous section's content
      if (currentSectionIndex >= 0 && !sections[currentSectionIndex].isMetadata) {
        sections[currentSectionIndex].content = currentContent.join('\n').trim();
      }
      currentSectionIndex = headingMatch;
      currentContent = [];
    } else if (currentSectionIndex >= 0 && !sections[currentSectionIndex].isMetadata) {
      // Add to current section content (skip metadata sections)
      if (line.trim() !== '' || currentContent.length > 0) {
        currentContent.push(line);
      }
    }
  }

  // Save last section's content
  if (currentSectionIndex >= 0 && !sections[currentSectionIndex].isMetadata) {
    sections[currentSectionIndex].content = currentContent.join('\n').trim();
  }

  return sections;
}

// Helper function to build LS-ilmoitus markdown from structured Firestore fields
function buildLSIlmoitusMarkdown(doc: FirestoreService.LSNotificationDocument): string {
  return `# Lastensuojeluhakemus

## P√ÑIV√ÑYS
${doc.paivays || ''}

## ILMOITTAJAN TIEDOT
${doc.ilmoittajanTiedot || ''}

## LAPSEN TIEDOT
${doc.lapsenTiedot || ''}

## HUOLTAJIEN TIEDOT
${doc.huoltajienTiedot || ''}

## HUOLEN AIHEET
${doc.huolenAiheet || ''}

## ILMOITUKSEN PERUSTE
${doc.ilmoituksenPeruste || ''}

## TOIMENPITEET
${doc.toimenpiteet || ''}

## ALLEKIRJOITUS JA K√ÑSITTELYN P√Ñ√ÑTTYMISP√ÑIV√ÑM√Ñ√ÑR√Ñ
${doc.allekirjoitusJaKasittely || ''}`;
}

// Helper function to parse LS-ilmoitus markdown into structured fields
function parseLSIlmoitusMarkdown(markdown: string): Partial<FirestoreService.LSNotificationDocument> {
  const sections: Partial<FirestoreService.LSNotificationDocument> = {};

  const paivaysMatch = markdown.match(/## P√ÑIV√ÑYS\s*([\s\S]*?)(?=##|$)/);
  if (paivaysMatch) sections.paivays = paivaysMatch[1].trim();

  const ilmoittajaMatch = markdown.match(/## ILMOITTAJAN TIEDOT\s*([\s\S]*?)(?=##|$)/);
  if (ilmoittajaMatch) sections.ilmoittajanTiedot = ilmoittajaMatch[1].trim();

  const lapsiMatch = markdown.match(/## LAPSEN TIEDOT\s*([\s\S]*?)(?=##|$)/);
  if (lapsiMatch) sections.lapsenTiedot = lapsiMatch[1].trim();

  const huoltajatMatch = markdown.match(/## HUOLTAJIEN TIEDOT\s*([\s\S]*?)(?=##|$)/);
  if (huoltajatMatch) sections.huoltajienTiedot = huoltajatMatch[1].trim();

  const huoletMatch = markdown.match(/## HUOLEN AIHEET\s*([\s\S]*?)(?=##|$)/);
  if (huoletMatch) sections.huolenAiheet = huoletMatch[1].trim();

  const perusteMatch = markdown.match(/## ILMOITUKSEN PERUSTE\s*([\s\S]*?)(?=##|$)/);
  if (perusteMatch) sections.ilmoituksenPeruste = perusteMatch[1].trim();

  const toimenpiteetMatch = markdown.match(/## TOIMENPITEET\s*([\s\S]*?)(?=##|$)/);
  if (toimenpiteetMatch) sections.toimenpiteet = toimenpiteetMatch[1].trim();

  const allekirjoitusMatch = markdown.match(/## ALLEKIRJOITUS JA K√ÑSITTELYN P√Ñ√ÑTTYMISP√ÑIV√ÑM√Ñ√ÑR√Ñ\s*([\s\S]*?)(?=##|$)/);
  if (allekirjoitusMatch) sections.allekirjoitusJaKasittely = allekirjoitusMatch[1].trim();

  return sections;
}

// Helper function to build PTA markdown from structured Firestore fields
function buildPTAMarkdown(doc: FirestoreService.PTADocument): string {
  return `## P√§iv√§ys
${doc.paivays || ''}

## PERHE
${doc.perhe || ''}

## TAUSTA
${doc.tausta || ''}

## PALVELUT
${doc.palvelut || ''}

## YHTEISTY√ñTAHOT ja VERKOSTO
${doc.yhteistyotahotJaVerkosto || ''}

## LAPSEN JA PERHEEN TAPAAMINEN
${doc.lapsenJaPerheenTapaaminen || ''}

## ASIAKKAAN MIELIPIDE JA N√ÑKEMYS PALVELUTARPEESEEN
${doc.asiakkaanMielipideJaNakemys || ''}

## SOSIAALIHUOLLON AMMATTIHENKIL√ñN JOHTOP√Ñ√ÑT√ñKSET
${doc.sosiaalityontekijanJohtop√§√§t√∂kset || ''}

## ARVIO OMATY√ñNTEKIJ√ÑN TARPEESTA
${doc.arvioOmatyontekijanTarpeesta || ''}

## JAKELU JA ALLEKIRJOITUS
${doc.jakeluJaAllekirjoitus || ''}`;
}

// Helper function to parse PTA markdown into structured fields
function parsePTAMarkdown(markdown: string): Partial<FirestoreService.PTADocument> {
  const sections: Partial<FirestoreService.PTADocument> = {};

  const paivaysMatch = markdown.match(/## P√§iv√§ys\s*([\s\S]*?)(?=##|$)/);
  if (paivaysMatch) sections.paivays = paivaysMatch[1].trim();

  const perheMatch = markdown.match(/## PERHE\s*([\s\S]*?)(?=##|$)/);
  if (perheMatch) sections.perhe = perheMatch[1].trim();

  const taustaMatch = markdown.match(/## TAUSTA\s*([\s\S]*?)(?=##|$)/);
  if (taustaMatch) sections.tausta = taustaMatch[1].trim();

  const palvelutMatch = markdown.match(/## PALVELUT\s*([\s\S]*?)(?=##|$)/);
  if (palvelutMatch) sections.palvelut = palvelutMatch[1].trim();

  const yhteistyoMatch = markdown.match(/## YHTEISTY√ñTAHOT ja VERKOSTO\s*([\s\S]*?)(?=##|$)/);
  if (yhteistyoMatch) sections.yhteistyotahotJaVerkosto = yhteistyoMatch[1].trim();

  const tapaaminenMatch = markdown.match(/## LAPSEN JA PERHEEN TAPAAMINEN\s*([\s\S]*?)(?=##|$)/);
  if (tapaaminenMatch) sections.lapsenJaPerheenTapaaminen = tapaaminenMatch[1].trim();

  const mielipideMatch = markdown.match(/## ASIAKKAAN MIELIPIDE JA N√ÑKEMYS PALVELUTARPEESEEN\s*([\s\S]*?)(?=##|$)/);
  if (mielipideMatch) sections.asiakkaanMielipideJaNakemys = mielipideMatch[1].trim();

  const johtop√§√§t√∂ksetMatch = markdown.match(/## SOSIAALIHUOLLON AMMATTIHENKIL√ñN JOHTOP√Ñ√ÑT√ñKSET\s*([\s\S]*?)(?=##|$)/);
  if (johtop√§√§t√∂ksetMatch) sections.sosiaalityontekijanJohtop√§√§t√∂kset = johtop√§√§t√∂ksetMatch[1].trim();

  const arvioMatch = markdown.match(/## ARVIO OMATY√ñNTEKIJ√ÑN TARPEESTA\s*([\s\S]*?)(?=##|$)/);
  if (arvioMatch) sections.arvioOmatyontekijanTarpeesta = arvioMatch[1].trim();

  const jakeluMatch = markdown.match(/## JAKELU JA ALLEKIRJOITUS\s*([\s\S]*?)(?=##|$)/);
  if (jakeluMatch) sections.jakeluJaAllekirjoitus = jakeluMatch[1].trim();

  return sections;
}

// Helper function to build p√§√§t√∂s markdown from structured Firestore fields
function buildPaatosMarkdown(doc: FirestoreService.DecisionDocument): string {
  return `## RATKAISU TAI P√Ñ√ÑT√ñS
${doc.ratkaisuTaiPaatos || ''}

## ASIAN VIREILLETULOP√ÑIV√Ñ
${doc.asianVireilletulopaiva || new Date().toLocaleDateString('fi-FI')}

## ASIAN KESKEINEN SIS√ÑLT√ñ
${doc.asianKeskeinenSisalto || ''}

## P√Ñ√ÑT√ñKSEN PERUSTELUT JA TOIMEENPANO
${doc.paatoksenPerustelutJaToimeenpano || ''}

## RATKAISU VOIMASSA
${doc.ratkaisuVoimassa || ''}

## VALMISTELIJA / LAPSEN ASIOISTA VASTAAVA SOSIAALITY√ñNTEKIJ√Ñ
${doc.valmistelijaJaSosiaalityontekija || ''}

## RATKAISIJA / VASTUUSOSIAALITY√ñNTEKIJ√Ñ / JOHTAVA SOSIAALITY√ñNTEKIJ√Ñ
${doc.ratkaisija || ''}

## TIEDOKSIANTO PMV
${doc.tiedoksiantoPMV || ''}`;
}

// Helper function to parse p√§√§t√∂s markdown into structured fields
function parsePaatosMarkdown(markdown: string): Partial<FirestoreService.DecisionDocument> {
  const sections: Partial<FirestoreService.DecisionDocument> = {};

  // Parse each section
  const ratkaisuMatch = markdown.match(/## RATKAISU TAI P√Ñ√ÑT√ñS\s*([\s\S]*?)(?=##|$)/);
  if (ratkaisuMatch) sections.ratkaisuTaiPaatos = ratkaisuMatch[1].trim();

  const vireilletuloMatch = markdown.match(/## ASIAN VIREILLETULOP√ÑIV√Ñ\s*([\s\S]*?)(?=##|$)/);
  if (vireilletuloMatch) sections.asianVireilletulopaiva = vireilletuloMatch[1].trim();

  const sisaltoMatch = markdown.match(/## ASIAN KESKEINEN SIS√ÑLT√ñ\s*([\s\S]*?)(?=##|$)/);
  if (sisaltoMatch) sections.asianKeskeinenSisalto = sisaltoMatch[1].trim();

  const perustelutMatch = markdown.match(/## P√Ñ√ÑT√ñKSEN PERUSTELUT JA TOIMEENPANO\s*([\s\S]*?)(?=##|$)/);
  if (perustelutMatch) sections.paatoksenPerustelutJaToimeenpano = perustelutMatch[1].trim();

  const voimassaMatch = markdown.match(/## RATKAISU VOIMASSA\s*([\s\S]*?)(?=##|$)/);
  if (voimassaMatch) sections.ratkaisuVoimassa = voimassaMatch[1].trim();

  const valmistelijaMatch = markdown.match(/## VALMISTELIJA \/ LAPSEN ASIOISTA VASTAAVA SOSIAALITY√ñNTEKIJ√Ñ\s*([\s\S]*?)(?=##|$)/);
  if (valmistelijaMatch) sections.valmistelijaJaSosiaalityontekija = valmistelijaMatch[1].trim();

  const ratkaisijaMatch = markdown.match(/## RATKAISIJA \/ VASTUUSOSIAALITY√ñNTEKIJ√Ñ \/ JOHTAVA SOSIAALITY√ñNTEKIJ√Ñ\s*([\s\S]*?)(?=##|$)/);
  if (ratkaisijaMatch) sections.ratkaisija = ratkaisijaMatch[1].trim();

  const tiedoksiantoMatch = markdown.match(/## TIEDOKSIANTO PMV\s*([\s\S]*?)(?=##|$)/);
  if (tiedoksiantoMatch) sections.tiedoksiantoPMV = tiedoksiantoMatch[1].trim();

  return sections;
}

// Helper function to combine sections back into markdown
function combineSectionsToMarkdown(sections: DocumentSection[]): string {
  return sections
    .map((section) => {
      if (section.isMetadata) {
        return section.heading;
      }
      if (section.content.trim()) {
        return `${section.heading}\n${section.content}`;
      }
      return section.heading;
    })
    .join('\n\n');
}

// Auto-population helper functions
async function getLapsenTiedot(clientId: string): Promise<string> {
  const basicInfo = await getClientBasicInfo(clientId);
  if (!basicInfo || !basicInfo.child) {
    return '‚ö†Ô∏è Ei lapsen tietoja saatavilla - lis√§√§ tiedot ASIAKAS_PERUSTIEDOT-osiossa';
  }

  const child = basicInfo.child;
  let result = `**Nimi:** ${child.nimi || '-'}`;
  if (child.puhelin) {
    result += `\n**Puhelin:** ${child.puhelin}`;
  }
  if (child.koulu) {
    result += `\n**Koulu:** ${child.koulu}`;
  }
  if (child.koulunPuhelin) {
    result += `\n**Koulun puhelin:** ${child.koulunPuhelin}`;
  }
  return result;
}

async function getHuoltajienTiedot(clientId: string): Promise<string> {
  const basicInfo = await getClientBasicInfo(clientId);
  if (!basicInfo || !basicInfo.guardians || basicInfo.guardians.length === 0) {
    return '‚ö†Ô∏è Ei huoltajien tietoja saatavilla - lis√§√§ tiedot ASIAKAS_PERUSTIEDOT-osiossa';
  }

  const guardians = basicInfo.guardians;
  const aiti = guardians.find(g => g.rooli?.toLowerCase() === '√§iti');
  const isa = guardians.find(g => g.rooli?.toLowerCase() === 'is√§');

  let result = '';

  if (aiti) {
    result += `**√Ñiti:**\n`;
    result += `- Nimi: ${aiti.nimi || '-'}\n`;
    if (aiti.puhelin) result += `- Puhelin: ${aiti.puhelin}\n`;
    if (aiti.sahkoposti) result += `- S√§hk√∂posti: ${aiti.sahkoposti}\n`;
    if (aiti.osoite) result += `- Osoite: ${aiti.osoite}\n`;
    result += '\n';
  }

  if (isa) {
    result += `**Is√§:**\n`;
    result += `- Nimi: ${isa.nimi || '-'}\n`;
    if (isa.puhelin) result += `- Puhelin: ${isa.puhelin}\n`;
    if (isa.sahkoposti) result += `- S√§hk√∂posti: ${isa.sahkoposti}\n`;
    if (isa.osoite) result += `- Osoite: ${isa.osoite}`;
  }

  return result.trim() || '‚ö†Ô∏è Ei huoltajien tietoja saatavilla';
}

export default function MarkdownDocumentEditor({
  open,
  onClose,
  documentType,
  clientId,
  existingContent,
  existingFilename,
  onSaved,
}: MarkdownDocumentEditorProps) {
  const [sections, setSections] = useState<DocumentSection[]>([]);
  const [saving, setSaving] = useState(false);
  const [message, setMessage] = useState('');
  const [error, setError] = useState('');
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [ptaStatus, setPtaStatus] = useState<'Kesken' | 'Tulostettu'>('Kesken');
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  const handleClose = () => {
    console.log('üîµ [MarkdownDocumentEditor] handleClose called');
    console.log('  - hasUnsavedChanges:', hasUnsavedChanges);
    console.log('  - will call onSaved:', hasUnsavedChanges && !!onSaved);

    // Call onSaved only when closing if there were changes
    if (hasUnsavedChanges && onSaved) {
      console.log('üîÑ [MarkdownDocumentEditor] Calling onSaved callback');
      onSaved();
    }
    console.log('üö™ [MarkdownDocumentEditor] Calling onClose to close dialog');
    onClose();
  };

  // Initialize sections when dialog opens
  useEffect(() => {
    if (open) {
      console.log('üîµ [MarkdownDocumentEditor] Dialog opened');
      console.log('  - documentType:', documentType);
      console.log('  - existingFilename:', existingFilename);
      console.log('  - existingContent length:', existingContent?.length || 0);
      console.log('  - Delete button will show:', !!existingFilename);

      const initializeDocument = async () => {
        const structure = DOCUMENT_STRUCTURES[documentType] || [];

        // Special handling for p√§√§t√∂s documents with structured fields
        if (documentType === 'p√§√§t√∂s' && existingFilename && !existingContent) {
          try {
            // Extract docId from filename
            const docId = existingFilename.replace('.md', '');
            console.log('üìÇ [MarkdownDocumentEditor] Loading p√§√§t√∂s document from Firestore:', docId);

            const doc = await FirestoreService.getDocument('P√Ñ√ÑT√ñKSET', docId) as FirestoreService.DecisionDocument;

            if (doc && doc.ratkaisuTaiPaatos) {
              // Has structured fields - build markdown from them
              console.log('‚úÖ [MarkdownDocumentEditor] Found structured fields, building markdown');
              const markdown = buildPaatosMarkdown(doc);
              setSections(parseContentIntoSections(markdown, structure));
            } else {
              console.error('‚ùå [MarkdownDocumentEditor] P√§√§t√∂s document missing structured fields:', docId);
              // Initialize empty structure
              setSections(structure.map(s => ({ ...s, content: '' })));
            }
          } catch (error) {
            console.error('‚ùå [MarkdownDocumentEditor] Error loading p√§√§t√∂s document:', error);
          }
        }
        // Special handling for LS-ilmoitus documents with structured fields
        else if (documentType === 'ls-ilmoitus' && existingFilename && !existingContent) {
          try {
            const docId = existingFilename.replace('.md', '');
            console.log('üìÇ [MarkdownDocumentEditor] Loading LS-ilmoitus document from Firestore:', docId);

            const doc = await FirestoreService.getDocument('LASTENSUOJELUILMOITUKSET', docId) as FirestoreService.LSNotificationDocument;

            if (doc && doc.paivays) {
              // Has structured fields - build markdown from them
              console.log('‚úÖ [MarkdownDocumentEditor] Found structured fields, building markdown');
              const markdown = buildLSIlmoitusMarkdown(doc);
              setSections(parseContentIntoSections(markdown, structure));
            } else {
              console.error('‚ùå [MarkdownDocumentEditor] LS-ilmoitus document missing structured fields:', docId);
              setSections(structure.map(s => ({ ...s, content: '' })));
            }
          } catch (error) {
            console.error('‚ùå [MarkdownDocumentEditor] Error loading LS-ilmoitus document:', error);
          }
        }
        // Special handling for PTA documents with structured fields
        else if (documentType === 'pta' && existingFilename && !existingContent) {
          try {
            const docId = existingFilename.replace('.md', '');
            console.log('üìÇ [MarkdownDocumentEditor] Loading PTA document from Firestore:', docId);

            const doc = await FirestoreService.getDocument('PALVELUTARVEARVIOINNIT', docId) as FirestoreService.PTADocument;

            if (doc && doc.paivays) {
              // Has structured fields - build markdown from them
              console.log('‚úÖ [MarkdownDocumentEditor] Found structured fields, building markdown');
              const markdown = buildPTAMarkdown(doc);
              setSections(parseContentIntoSections(markdown, structure));

              // Set PTA status if available
              if (doc.status) {
                setPtaStatus(doc.status);
              }
            } else {
              console.error('‚ùå [MarkdownDocumentEditor] PTA document missing structured fields:', docId);
              setSections(structure.map(s => ({ ...s, content: '' })));
            }
          } catch (error) {
            console.error('‚ùå [MarkdownDocumentEditor] Error loading PTA document:', error);
          }
        }
        else if (existingContent) {
          const parsedSections = parseContentIntoSections(existingContent, structure);

          // Auto-populate empty fields for LS-ilmoitus (uploaded documents)
          if (documentType === 'ls-ilmoitus') {
            const updatedSections = [...parsedSections];

            // Helper function to check if content is empty or placeholder
            const isEmptyOrPlaceholder = (content: string): boolean => {
              const trimmed = content.trim();
              return !trimmed ||
                     trimmed.includes('Automaattinen') ||
                     trimmed.includes('√ÑL√Ñ t√§yt√§') ||
                     trimmed.startsWith('[') && trimmed.endsWith(']');
            };

            // Auto-populate P√ÑIV√ÑYS if empty or placeholder
            const paivaysIndex = updatedSections.findIndex(s => s.heading === '## P√ÑIV√ÑYS');
            if (paivaysIndex !== -1 && isEmptyOrPlaceholder(updatedSections[paivaysIndex].content)) {
              updatedSections[paivaysIndex].content = new Date().toLocaleDateString('fi-FI');
              console.log('üìÖ [MarkdownDocumentEditor] Auto-filled P√ÑIV√ÑYS for uploaded document');
            }

            // Auto-populate LAPSEN TIEDOT if empty or placeholder
            const lapsiIndex = updatedSections.findIndex(s => s.heading === '## LAPSEN TIEDOT');
            if (lapsiIndex !== -1 && isEmptyOrPlaceholder(updatedSections[lapsiIndex].content)) {
              updatedSections[lapsiIndex].content = await getLapsenTiedot(clientId);
              console.log('üë∂ [MarkdownDocumentEditor] Auto-filled LAPSEN TIEDOT for uploaded document');
            }

            // Auto-populate HUOLTAJIEN TIEDOT if empty or placeholder
            const huoltajatIndex = updatedSections.findIndex(s => s.heading === '## HUOLTAJIEN TIEDOT');
            if (huoltajatIndex !== -1 && isEmptyOrPlaceholder(updatedSections[huoltajatIndex].content)) {
              updatedSections[huoltajatIndex].content = await getHuoltajienTiedot(clientId);
              console.log('üë®‚Äçüë©‚Äçüëß [MarkdownDocumentEditor] Auto-filled HUOLTAJIEN TIEDOT for uploaded document');
            }

            setSections(updatedSections);
          } else {
            setSections(parsedSections);
          }

          // Extract PTA status if exists
          if (documentType === 'pta') {
            const statusMatch = existingContent.match(/<!--\s*STATUS:\s*(Kesken|Tulostettu)\s*-->/);
            if (statusMatch) {
              setPtaStatus(statusMatch[1] as 'Kesken' | 'Tulostettu');
            }
          }
        } else {
          // For new ls-ilmoitus documents, auto-populate fields
          if (documentType === 'ls-ilmoitus') {
            const newStructure = [...structure];

            // Auto-populate P√ÑIV√ÑYS
            const paivaysIndex = newStructure.findIndex(s => s.heading === '## P√ÑIV√ÑYS');
            if (paivaysIndex !== -1) {
              newStructure[paivaysIndex].content = new Date().toLocaleDateString('fi-FI');
            }

            // Pre-fill ILMOITTAJAN TIEDOT with template
            const ilmoittajaIndex = newStructure.findIndex(s => s.heading === '## ILMOITTAJAN TIEDOT');
            if (ilmoittajaIndex !== -1) {
              newStructure[ilmoittajaIndex].content = '**Nimi:**\n**Puhelin:**\n**Suhde lapseen:**';
            }

            // Auto-populate LAPSEN TIEDOT
            const lapsiIndex = newStructure.findIndex(s => s.heading === '## LAPSEN TIEDOT');
            if (lapsiIndex !== -1) {
              newStructure[lapsiIndex].content = await getLapsenTiedot(clientId);
            }

            // Auto-populate HUOLTAJIEN TIEDOT
            const huoltajatIndex = newStructure.findIndex(s => s.heading === '## HUOLTAJIEN TIEDOT');
            if (huoltajatIndex !== -1) {
              newStructure[huoltajatIndex].content = await getHuoltajienTiedot(clientId);
            }

            setSections(newStructure);
          } else {
            setSections(structure);
          }

          setPtaStatus('Kesken');
        }
        setMessage('');
        setError('');
        setHasUnsavedChanges(false);
      };

      initializeDocument();
    } else {
      // RESET all state when dialog closes
      console.log('üîµ [MarkdownDocumentEditor] Dialog closed - resetting state');
      setSections([]);
      setPtaStatus('Kesken');
      setMessage('');
      setError('');
      setHasUnsavedChanges(false);
    }
  }, [open, documentType, existingContent, existingFilename, clientId]);

  const updateSectionContent = (index: number, newContent: string) => {
    setSections((prev) =>
      prev.map((section, i) => (i === index ? { ...section, content: newContent } : section))
    );
  };

  const handleSave = async () => {
    console.log('üîµ [MarkdownDocumentEditor] handleSave called');
    console.log('  - documentType:', documentType);
    console.log('  - clientId:', clientId);
    console.log('  - existingFilename:', existingFilename);

    let combinedContent = combineSectionsToMarkdown(sections);

    if (!combinedContent.trim()) {
      setError('Dokumentti ei voi olla tyhj√§');
      return;
    }

    setSaving(true);
    setMessage('Luodaan yhteenvetoa...');
    setError('');

    try {
      // Map documentType to Firestore collection
      const categoryMap: Record<DocumentType, DocumentCategory> = {
        'ls-ilmoitus': 'ls-ilmoitus',
        'p√§√§t√∂s': 'p√§√§t√∂s',
        'pta': 'pta-record',
        'asiakassuunnitelma': 'asiakassuunnitelma',
        'asiakaskirjaus': 'asiakaskirjaus', // Case notes stored in ASIAKASKIRJAUKSET
        'yhteystiedot': 'ls-ilmoitus', // Contact info stored as LS notification
      };

      const category = categoryMap[documentType];
      const collectionName = FirestoreService.getCollectionFromCategory(category);

      // Extract date from markdown content
      const extractedDate = extractDateFromMarkdown(combinedContent);

      // Clean fullMarkdownText: Remove STATUS comments (now stored in separate field)
      const cleanedMarkdown = combinedContent.replace(/<!--\s*STATUS:\s*(Kesken|Tulostettu)\s*-->\n*/g, '');

      // Prepare document data
      const documentData: Partial<FirestoreService.FirestoreDocument> = {
        clientId,
        date: extractedDate,
        category,
        ...(documentType === 'p√§√§t√∂s' && !existingFilename && { editor: 'ihminen' }), // Mark manually created documents
      };

      // For p√§√§t√∂s documents, parse markdown into structured fields (no fullMarkdownText!)
      if (documentType === 'p√§√§t√∂s') {
        const parsedFields = parsePaatosMarkdown(cleanedMarkdown);
        Object.assign(documentData, parsedFields);
        console.log('üìù [MarkdownDocumentEditor] Parsed p√§√§t√∂s structured fields:', parsedFields);
      }
      // For LS-ilmoitus documents, parse markdown into structured fields (no fullMarkdownText!)
      else if (documentType === 'ls-ilmoitus') {
        const parsedFields = parseLSIlmoitusMarkdown(cleanedMarkdown);
        Object.assign(documentData, parsedFields);
        console.log('üìù [MarkdownDocumentEditor] Parsed LS-ilmoitus structured fields:', parsedFields);
      }
      // For PTA documents, parse markdown into structured fields (no fullMarkdownText!)
      else if (documentType === 'pta') {
        const parsedFields = parsePTAMarkdown(cleanedMarkdown);
        Object.assign(documentData, parsedFields);
        console.log('üìù [MarkdownDocumentEditor] Parsed PTA structured fields:', parsedFields);
      }
      // Other document types (asiakassuunnitelma, asiakaskirjaus) still use fullMarkdownText
      else {
        documentData.fullMarkdownText = cleanedMarkdown;
      }

      // Add PTA-specific fields
      if (documentType === 'pta') {
        (documentData as Partial<FirestoreService.PTADocument>).status = ptaStatus;
      }

      // Add editor field for p√§√§t√∂s documents (manual edits are always 'ihminen')
      if (documentType === 'p√§√§t√∂s') {
        (documentData as Partial<FirestoreService.DecisionDocument>).editor = 'ihminen';
        console.log('üìù [MarkdownDocumentEditor] Marking p√§√§t√∂s as manual edit (editor: ihminen)');
      }

      // Extract docId from existingFilename if editing
      let docId: string | undefined;
      if (existingFilename) {
        // existingFilename format: "{clientId}_{timestamp}.md"
        docId = existingFilename.replace('.md', '');
      }

      console.log('  - Saving to Firestore collection:', collectionName);
      console.log('  - Document ID:', docId || 'new document');
      console.log('  - Generating LLM summary...');

      // Save to Firestore (generates LLM summary automatically)
      const savedDocId = await FirestoreService.saveDocument(
        collectionName,
        documentData,
        docId
      );

      console.log('‚úÖ [MarkdownDocumentEditor] Save successful, document ID:', savedDocId);

      // For case notes, close automatically after save
      if (documentType === 'asiakaskirjaus') {
        setMessage('‚úÖ Asiakaskirjaus tallennettu!');
        setTimeout(() => {
          if (onSaved) {
            onSaved(); // Trigger parent refresh
          }
          onClose(); // Close the editor dialog
        }, 800);
      } else {
        setMessage('‚úÖ Dokumentti tallennettu onnistuneesti! Voit jatkaa muokkausta tai sulkea ikkunan.');
        setHasUnsavedChanges(true);
        // Don't close automatically for other document types - let user decide
      }
    } catch (err) {
      console.error('‚ùå [MarkdownDocumentEditor] Error saving document:', err);
      setError('Virhe tallennuksessa. Yrit√§ uudelleen.');
    } finally {
      setSaving(false);
    }
  };

  const handleDelete = async () => {
    if (!existingFilename) {
      setError('Ei tiedostoa poistettavaksi');
      return;
    }

    setIsDeleting(true);
    setError('');

    try {
      // Map documentType to Firestore collection
      const categoryMap: Record<DocumentType, DocumentCategory> = {
        'ls-ilmoitus': 'ls-ilmoitus',
        'p√§√§t√∂s': 'p√§√§t√∂s',
        'pta': 'pta-record',
        'asiakassuunnitelma': 'asiakassuunnitelma',
        'asiakaskirjaus': 'asiakaskirjaus', // Case notes stored in ASIAKASKIRJAUKSET
        'yhteystiedot': 'ls-ilmoitus',
      };

      const category = categoryMap[documentType];
      const collectionName = FirestoreService.getCollectionFromCategory(category);

      // Extract docId from existingFilename
      const docId = existingFilename.replace('.md', '');

      console.log('üîµ [MarkdownDocumentEditor] Deleting from Firestore');
      console.log('  - Collection:', collectionName);
      console.log('  - Document ID:', docId);

      const success = await FirestoreService.deleteDocument(collectionName, docId);

      if (success) {
        setMessage('‚úÖ Dokumentti poistettu onnistuneesti!');
        console.log('üîµ [MarkdownDocumentEditor] Document deleted, closing both dialogs');
        // Close both dialogs and trigger data refresh
        setTimeout(() => {
          if (onSaved) {
            console.log('üîÑ [MarkdownDocumentEditor] Calling onSaved to close parent dialog');
            onSaved(); // This closes PTADocumentDialog and refreshes data
          }
          onClose(); // Close MarkdownDocumentEditor
        }, 1000);
      } else {
        setError('Poisto ep√§onnistui. Tarkista ett√§ olet kirjautunut sis√§√§n.');
      }
    } catch (err) {
      console.error('Error deleting document:', err);
      setError('Virhe poistossa. Yrit√§ uudelleen.');
    } finally {
      setIsDeleting(false);
      setShowDeleteDialog(false);
    }
  };

  const documentTitles: Record<DocumentType, string> = {
    'ls-ilmoitus': 'Lastensuojeluhakemus',
    'p√§√§t√∂s': 'P√§√§t√∂s',
    'pta': 'Palvelutarpeen arviointi',
    'asiakassuunnitelma': 'Asiakassuunnitelma',
    'asiakaskirjaus': 'Asiakaskirjaus',
    'yhteystiedot': 'Yhteystiedot',
  };

  return (
    <>
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent
        className={`${
          isFullscreen
            ? 'w-screen h-screen max-w-none max-h-none m-0 rounded-none'
            : 'max-w-7xl max-h-[95vh]'
        } overflow-hidden flex flex-col`}
      >
        <DialogHeader>
          <div className="flex items-center justify-between">
            <div>
              <DialogTitle className="flex items-center gap-2">
                <Edit3 className="w-5 h-5" />
                {existingFilename ? 'Muokkaa dokumenttia' : 'Luo uusi'} - {documentTitles[documentType]}
              </DialogTitle>
              <DialogDescription>
                {existingFilename
                  ? `Muokkaa dokumenttia: ${existingFilename}`
                  : 'Luo uusi dokumentti Markdown-muodossa'
                }
              </DialogDescription>
            </div>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => setIsFullscreen(!isFullscreen)}
              className="h-8 w-8 p-0"
            >
              {isFullscreen ? (
                <Minimize2 className="h-4 w-4" />
              ) : (
                <Maximize2 className="h-4 w-4" />
              )}
            </Button>
          </div>
        </DialogHeader>

        {/* Messages */}
        {message && (
          <Alert>
            <Check className="h-4 w-4" />
            <AlertDescription>{message}</AlertDescription>
          </Alert>
        )}

        {error && (
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        {/* Toolbar */}
        <div className="flex flex-col gap-3 border-b pb-3">
          {/* PTA Status Selector */}
          {documentType === 'pta' && (
            <div className="flex items-center gap-2">
              <Label htmlFor="pta-status" className="text-sm">Status:</Label>
              <Select value={ptaStatus} onValueChange={(value) => setPtaStatus(value as 'Kesken' | 'Tulostettu')}>
                <SelectTrigger id="pta-status" className="h-8 w-[140px]">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Kesken">Kesken</SelectItem>
                  <SelectItem value="Tulostettu">Tulostettu</SelectItem>
                </SelectContent>
              </Select>
            </div>
          )}

        </div>

        {/* Structured Editor - Word-like Layout */}
        <div className="flex-1 overflow-y-auto pr-2 bg-white">
          <div className="max-w-4xl mx-auto p-8 space-y-6">
            {sections.map((section, originalIndex) => {
              // Skip metadata sections in rendering
              if (section.isMetadata) return null;

              return (
                <div key={originalIndex} className="space-y-3">
                  {/* Heading as styled text (Word-like) */}
                  {section.heading.startsWith('# ') && (
                    <h1 className="text-2xl font-bold text-gray-900 mt-6 mb-3">
                      {section.heading.replace(/^# /, '')}
                    </h1>
                  )}
                  {section.heading.startsWith('## ') && (
                    <h2 className="text-xl font-semibold text-gray-800 mt-5 mb-2 uppercase tracking-wide">
                      {section.heading.replace(/^## /, '')}
                    </h2>
                  )}
                  {section.heading.startsWith('### ') && (
                    <h3 className="text-lg font-medium text-gray-700 mt-4 mb-2">
                      {section.heading.replace(/^### /, '')}
                    </h3>
                  )}
                  {!section.heading.startsWith('#') && (
                    <div className="text-sm font-mono text-gray-600">
                      {section.heading}
                    </div>
                  )}

                  {/* Editable Content - Clean textarea */}
                  {section.readOnly ? (
                    <div className="relative">
                      <div className="absolute top-2 right-2 flex items-center gap-1 text-xs text-gray-500 bg-gray-100 px-2 py-1 rounded">
                        <Lock className="w-3 h-3" />
                        <span>Automaattinen</span>
                      </div>
                      <Textarea
                        value={section.content}
                        onChange={(e) => updateSectionContent(originalIndex, e.target.value)}
                        className="min-h-[120px] resize-y bg-gray-50 border-gray-200 text-gray-700 cursor-not-allowed"
                        placeholder="Automaattisesti luotu kentt√§"
                        disabled={true}
                      />
                    </div>
                  ) : (
                    <Textarea
                      value={section.content}
                      onChange={(e) => updateSectionContent(originalIndex, e.target.value)}
                      className="min-h-[120px] resize-y border-gray-300 focus:border-blue-500 focus:ring-1 focus:ring-blue-500"
                      placeholder={section.placeholder || 'Kirjoita sis√§lt√∂...'}
                    />
                  )}
                </div>
              );
            })}
          </div>
        </div>

        {/* Footer */}
        <DialogFooter className="flex justify-between items-center pt-4 border-t">
          <div>
            {existingFilename && (
              <Button
                variant="destructive"
                size="sm"
                onClick={() => setShowDeleteDialog(true)}
                disabled={saving || isDeleting}
              >
                <Trash2 className="w-4 h-4 mr-2" />
                Poista
              </Button>
            )}
          </div>
          <div className="flex gap-2">
            <Button variant="outline" onClick={handleClose} disabled={saving || isDeleting}>
              <X className="w-4 h-4 mr-2" />
              Sulje
            </Button>
            <Button onClick={handleSave} disabled={saving || isDeleting}>
              {saving ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  Tallennetaan...
                </>
              ) : (
                <>
                  <Save className="w-4 h-4 mr-2" />
                  Tallenna
                </>
              )}
            </Button>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>

    {/* Delete Confirmation Dialog */}
    <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
      <AlertDialogContent>
        <AlertDialogHeader>
          <AlertDialogTitle>Poista dokumentti</AlertDialogTitle>
          <AlertDialogDescription>
            Oletko varma ett√§ haluat poistaa t√§m√§n dokumentin? T√§t√§ toimintoa ei voi peruuttaa.
          </AlertDialogDescription>
          {existingFilename && (
            <div className="mt-2 p-3 bg-gray-50 rounded-lg">
              <p className="text-sm font-medium">{existingFilename}</p>
            </div>
          )}
        </AlertDialogHeader>
        <AlertDialogFooter>
          <AlertDialogCancel disabled={isDeleting}>
            Peruuta
          </AlertDialogCancel>
          <AlertDialogAction
            onClick={handleDelete}
            disabled={isDeleting}
            className="bg-red-600 hover:bg-red-700"
          >
            {isDeleting ? 'Poistetaan...' : 'Poista'}
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
    </>
  );
}
